import { NextRequest, NextResponse } from 'next/server'
import { getGitHubToken } from '../utils/github'
import { throttledFetch } from '../utils/github-rate-limit'

interface WorkflowRun {
  id: number
  name: string
  status: 'completed' | 'in_progress' | 'queued' | 'requested'
  conclusion: 'success' | 'failure' | 'cancelled' | 'skipped' | 'timed_out' | 'action_required' | null
  created_at: string
  updated_at: string
  run_started_at: string
  jobs_url: string
  logs_url: string
  check_suite_url: string
  artifacts_url: string
  cancel_url: string
  rerun_url: string
  workflow_url: string
  head_branch: string
  head_sha: string
  run_number: number
  event: string
  display_title: string
  actor?: {
    login: string
    id: number
    type: 'User' | 'Bot' | 'Organization'
    avatar_url: string
  }
  head_commit: {
    id: string
    message: string
    author: {
      name: string
      email: string
    }
  }
  repository: {
    id: number
    name: string
    full_name: string
  }
  head_repository: {
    id: number
    name: string
    full_name: string
  }
}

interface WorkflowMetrics {
  workflow_id: string
  workflow_name: string
  total_runs: number
  successful_runs: number
  failed_runs: number
  cancelled_runs: number
  in_progress_runs: number
  success_rate: number
  avg_duration_ms: number
  last_run: string
  runs_this_month: number
  runs_last_month: number
  trend: 'up' | 'down' | 'stable'
  manual_runs: number
  automatic_runs: number
  manual_run_percentage: number
  trigger_breakdown: {
    push: number
    pull_request: number
    schedule: number
    workflow_dispatch: number
    repository_dispatch: number
    workflow_run: number
    todd: number
    other: number
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const range = searchParams.get('range') as '24h' | '7d' | '30d' | '90d' || '30d'
    const repo = searchParams.get('repo') || 'Cook-Unity/pw-cookunity-automation'
    
    const token = await getGitHubToken(request)
    if (!token) {
      return NextResponse.json({ 
        error: 'GitHub authentication required' 
      }, { status: 401 })
    }

    // Calculate dates based on range - always 1 month back + today
    const now = new Date()
    const startDate = new Date()
    
    // Always 30 days back + today (independent of range)
    startDate.setDate(now.getDate() - 30)
    
    // For specific range, adjust query but keep base period
    let queryRange = '30d'
    switch (range) {
      case '24h':
        queryRange = '24h'
        break
      case '7d':
        queryRange = '7d'
        break
      case '30d':
        queryRange = '30d'
        break
      case '90d':
        queryRange = '90d'
        break
    }

    // Get workflows from repository with pagination to get ALL workflows
    let allWorkflows: any[] = []
    let page = 1
    const perPage = 100
    
    while (true) {
      const workflowsResponse = await throttledFetch(
        `https://api.github.com/repos/${repo}/actions/workflows?page=${page}&per_page=${perPage}`,
        {
          headers: {
            'Authorization': `token ${token}`,
            'Accept': 'application/vnd.github.v3+json',
          },
          retries: 3,
          retryDelay: 2000,
          checkRateLimit: true
        }
      )

      if (!workflowsResponse.ok) {
        const errorText = await workflowsResponse.text().catch(() => workflowsResponse.statusText)
        throw new Error(`GitHub API error: ${workflowsResponse.status} ${errorText}`)
      }

      const workflowsData = await workflowsResponse.json()
      const pageWorkflows = workflowsData.workflows || []
      
      if (pageWorkflows.length === 0) {
        break // No more pages
      }
      
      allWorkflows = [...allWorkflows, ...pageWorkflows]
      
      // If we receive fewer workflows than perPage, it's the last page
      if (pageWorkflows.length < perPage) {
        break
      }
      
      page++
    }
    
    // Filter active workflows and exclude templates and dynamic workflows (same as /api/repositories)
    const activeWorkflows = allWorkflows.filter((workflow: any) => {
      const nameLower = workflow.name.toLowerCase()
      const pathLower = workflow.path.toLowerCase()
      
      // Excluir templates
      if (nameLower.includes('template') || pathLower.includes('template')) {
        return false
      }
      
      // Exclude dynamic workflows generated by PRs (auto-test-pr)
      if (nameLower.includes('auto test pr') || 
          nameLower.includes('auto-test-pr') ||
          pathLower.includes('auto-test-pr.yml') ||
          pathLower.includes('auto_test_pr')) {
        return false
      }
      
      return workflow.state === 'active'
    })
    
    // Limit workflows to avoid rate limits - prioritize most active ones
    // Reduced to 10 for presentation and to avoid rate limits
    const MAX_WORKFLOWS_TO_PROCESS = 10
    const workflows = activeWorkflows.slice(0, MAX_WORKFLOWS_TO_PROCESS)
    
    console.log(`üìä Metrics: Total workflows retrieved (with pagination) for ${repo}: ${allWorkflows.length}`)
    console.log(`üìä Metrics: Active workflows (after filter) for ${repo}: ${activeWorkflows.length}`)
    console.log(`üìä Metrics: Processing top ${workflows.length} workflows to avoid rate limits`)
    
    if (activeWorkflows.length > MAX_WORKFLOWS_TO_PROCESS) {
      console.warn(`‚ö†Ô∏è There are ${activeWorkflows.length} active workflows, but only processing ${MAX_WORKFLOWS_TO_PROCESS} to avoid rate limits`)
    }

    // Get runs for each workflow with additional throttling
    const workflowMetrics: WorkflowMetrics[] = []
    
    // Process in very small batches to avoid rate limits
    const BATCH_SIZE = 2
    for (let i = 0; i < workflows.length; i += BATCH_SIZE) {
      const batch = workflows.slice(i, i + BATCH_SIZE)
      
      const batchResults = await Promise.all(batch.map(async (workflow) => {
        try {
          // Get workflow runs - always 1 month back + today
          const runsResponse = await throttledFetch(
            `https://api.github.com/repos/${repo}/actions/workflows/${workflow.id}/runs?per_page=100&created=>${startDate.toISOString().split('T')[0]}`,
            {
              headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
              },
              retries: 2,
              retryDelay: 1500,
              checkRateLimit: true
            }
          )

          if (!runsResponse.ok) {
            const errorText = await runsResponse.text().catch(() => runsResponse.statusText)
            console.warn(`Failed to fetch runs for workflow ${workflow.name}: ${runsResponse.status} ${errorText}`)
            return null
          }

        const runsData = await runsResponse.json()
        let runs: WorkflowRun[] = runsData.workflow_runs || []

        // Filter runs according to selected queryRange
        if (queryRange !== '30d') {
          const rangeStartDate = new Date()
          switch (queryRange) {
            case '24h':
              rangeStartDate.setHours(rangeStartDate.getHours() - 24)
              break
            case '7d':
              rangeStartDate.setDate(rangeStartDate.getDate() - 7)
              break
          }
          runs = runs.filter(run => {
            const runDate = new Date(run.created_at)
            return runDate >= rangeStartDate
          })
        }

        // Calculate metrics
        const totalRuns = runs.length
        const successfulRuns = runs.filter(run => run.conclusion === 'success').length
        const failedRuns = runs.filter(run => run.conclusion === 'failure').length
        const cancelledRuns = runs.filter(run => run.conclusion === 'cancelled').length
        const inProgressRuns = runs.filter(run => run.status === 'in_progress' || run.status === 'queued').length
        
        // Count runs by trigger type (informative)
        // Detect runs triggered by TODD bot (actor is Bot with login containing "todd")
        const toddRuns = runs.filter(run => {
          if (run.event !== 'workflow_dispatch' && run.event !== 'repository_dispatch') return false;
          const actor = run.actor;
          return actor && actor.type === 'Bot' && actor.login.toLowerCase().includes('todd');
        }).length;
        
        const triggerBreakdown = {
          push: runs.filter(run => run.event === 'push').length,
          pull_request: runs.filter(run => run.event === 'pull_request').length,
          schedule: runs.filter(run => run.event === 'schedule').length,
          workflow_dispatch: runs.filter(run => {
            // workflow_dispatch but NOT by TODD (already counted in todd)
            if (run.event !== 'workflow_dispatch') return false;
            const actor = run.actor;
            if (actor && actor.type === 'Bot' && actor.login.toLowerCase().includes('todd')) {
              return false; // It's TODD, don't count here
            }
            return true; // Real manual (not TODD)
          }).length,
          repository_dispatch: runs.filter(run => {
            // repository_dispatch but NOT by TODD (already counted in todd)
            if (run.event !== 'repository_dispatch') return false;
            const actor = run.actor;
            if (actor && actor.type === 'Bot' && actor.login.toLowerCase().includes('todd')) {
              return false; // It's TODD, don't count here
            }
            return true; // Real dispatch (not TODD)
          }).length,
          workflow_run: runs.filter(run => run.event === 'workflow_run').length,
          todd: toddRuns,
          other: runs.filter(run => !['push', 'pull_request', 'schedule', 'workflow_dispatch', 'repository_dispatch', 'workflow_run'].includes(run.event)).length
        }
        
        // Count manual vs automatic runs
        // 'workflow_dispatch' = manual trigger from GitHub UI
        const manualRuns = triggerBreakdown.workflow_dispatch
        const automaticRuns = totalRuns - manualRuns
        const manualRunPercentage = totalRuns > 0 ? (manualRuns / totalRuns) * 100 : 0
        
        // Code triggers = push + pull_request (code introduction)
        const codeTriggers = triggerBreakdown.push + triggerBreakdown.pull_request
        
        const successRate = totalRuns > 0 ? (successfulRuns / totalRuns) * 100 : 0

        // Calculate average duration (only for completed runs)
        const completedRuns = runs.filter(run => run.conclusion && run.run_started_at)
        let avgDuration = 0
        
        if (completedRuns.length > 0) {
          const totalDuration = completedRuns.reduce((sum, run) => {
            const start = new Date(run.run_started_at).getTime()
            const end = new Date(run.updated_at).getTime()
            return sum + (end - start)
          }, 0)
          avgDuration = totalDuration / completedRuns.length
        }

        // Get last run
        const lastRun = runs.length > 0 ? runs[0].created_at : null

        // Calculate trend (compare first half vs second half of the month)
        const midMonth = new Date(startDate)
        midMonth.setDate(midMonth.getDate() + 15) // Middle of 30-day period
        
        const firstHalfRuns = runs.filter(run => {
          const runDate = new Date(run.created_at)
          return runDate >= startDate && runDate < midMonth
        }).length
        
        const secondHalfRuns = runs.filter(run => {
          const runDate = new Date(run.created_at)
          return runDate >= midMonth && runDate <= now
        }).length

        let trend: 'up' | 'down' | 'stable' = 'stable'
        if (secondHalfRuns > firstHalfRuns * 1.1) trend = 'up'
        else if (secondHalfRuns < firstHalfRuns * 0.9) trend = 'down'

        workflowMetrics.push({
          workflow_id: workflow.id.toString(),
          workflow_name: workflow.name,
          total_runs: totalRuns,
          successful_runs: successfulRuns,
          failed_runs: failedRuns,
          cancelled_runs: cancelledRuns,
          in_progress_runs: inProgressRuns,
          success_rate: successRate,
          avg_duration_ms: avgDuration,
          last_run: lastRun || '',
          runs_this_month: secondHalfRuns,
          runs_last_month: firstHalfRuns,
          trend,
          manual_runs: manualRuns,
          automatic_runs: automaticRuns,
          manual_run_percentage: manualRunPercentage,
          trigger_breakdown: triggerBreakdown
        })

        } catch (error) {
          console.warn(`Error processing workflow ${workflow.name}:`, error)
          return null
        }
      }))
      
      // Filtrar nulls y agregar a workflowMetrics
      batchResults.forEach(result => {
        if (result !== null) {
          workflowMetrics.push(result)
        }
      })
      
      // Longer pause between batches to avoid rate limiting
      if (i + BATCH_SIZE < workflows.length) {
        await new Promise(resolve => setTimeout(resolve, 1500))
      }
    }

    // Calculate aggregated metrics
    const totalWorkflows = workflowMetrics.length
    const totalRuns = workflowMetrics.reduce((sum, w) => sum + w.total_runs, 0)
    const totalSuccessful = workflowMetrics.reduce((sum, w) => sum + w.successful_runs, 0)
    const totalFailed = workflowMetrics.reduce((sum, w) => sum + w.failed_runs, 0)
    const overallSuccessRate = totalRuns > 0 ? (totalSuccessful / totalRuns) * 100 : 0
    
    // Calcular scheduled y manual runs totales
    const totalScheduledRuns = workflowMetrics.reduce((sum, w) => sum + (w.trigger_breakdown?.schedule || 0), 0)
    const totalManualRuns = workflowMetrics.reduce((sum, w) => sum + (w.trigger_breakdown?.workflow_dispatch || 0), 0)
    
    // Calculate weighted average duration (by number of runs)
    // This gives more weight to workflows that run more frequently
    let weightedAvgDuration = 0
    if (totalRuns > 0) {
      const totalDurationWeighted = workflowMetrics.reduce((sum, w) => {
        // Cada workflow contribuye proporcionalmente a sus runs
        return sum + (w.avg_duration_ms * w.total_runs)
      }, 0)
      weightedAvgDuration = totalDurationWeighted / totalRuns
    }
    
    // Find most active workflow (most runs)
    const mostActiveWorkflow = workflowMetrics.length > 0 
      ? workflowMetrics.reduce((max, w) => w.total_runs > max.total_runs ? w : max, workflowMetrics[0])
      : null

    return NextResponse.json({
      workflows: workflowMetrics,
      summary: {
        total_workflows: totalWorkflows,
        total_runs: totalRuns,
        successful_runs: totalSuccessful,
        failed_runs: totalFailed,
        success_rate: overallSuccessRate,
        avg_response_time: weightedAvgDuration, // Promedio ponderado por cantidad de runs
        in_progress_runs: workflowMetrics.reduce((sum, w) => sum + w.in_progress_runs, 0),
        scheduled_runs: totalScheduledRuns,
        manual_runs: totalManualRuns,
        most_active_workflow: mostActiveWorkflow ? {
          name: mostActiveWorkflow.workflow_name,
          runs: mostActiveWorkflow.total_runs
        } : null
      },
      time_range: '30d', // Always 30 days
      query_range: range, // Specific query range
      repository: repo,
      period: {
        start_date: startDate.toISOString().split('T')[0],
        end_date: now.toISOString().split('T')[0],
        days: 30
      },
      last_updated: new Date().toISOString()
    })

  } catch (error) {
    console.error('GitHub workflow metrics error:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    
    // Detect rate limit specifically
    if (errorMessage.includes('rate limit')) {
      return NextResponse.json(
        { 
          success: false,
          error: errorMessage,
          rateLimitExceeded: true
        },
        { status: 429 }
      )
    }
    
    return NextResponse.json(
      { 
        success: false,
        error: 'Failed to fetch workflow metrics from GitHub',
        details: errorMessage
      },
      { status: 500 }
    )
  }
}
